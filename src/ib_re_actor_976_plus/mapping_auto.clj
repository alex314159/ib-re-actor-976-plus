(ns ib-re-actor-976-plus.mapping-auto
  "Core mapping infrastructure for auto-generated IB class mappings.

  This namespace provides the protocol, multimethod, and macros needed for
  bidirectional conversion between IB Java classes and Clojure maps.

  Usage:
    (require '[ib-re-actor-976-plus.mapping-auto :refer [->map map->]])
    (require '[ib-re-actor-976-plus.generated-mappings])  ; Load implementations

    ;; Java object → Clojure map
    (->map my-order)

    ;; Clojure map → Java object
    (map-> com.ib.client.Order {:action :buy :quantity 100})

  This is the ONLY file you need to import in production code.
  The generated_mappings.clj file will automatically register all implementations."
  (:require
    [ib-re-actor-976-plus.translation :refer [translate]]))

;; ============================================================================
;; Public API - Import these in your code
;; ============================================================================

(defprotocol Mappable
  "Protocol for converting Java objects to Clojure maps."
  (->map [this]
    "Convert a Java object to a Clojure map with kebab-case keys."))

(defmulti map->
  "Multimethod for converting Clojure maps to Java objects.
  Dispatch on the Java class type."
  (fn [type _] type))

;; ============================================================================
;; Helper functions - MUST be public (used by macro-generated code)
;; ============================================================================

(defn assoc-if-val-non-nil
  "Chainable, conditional assoc. If v is not nil, assoc it and return the result,
  otherwise, don't and return m unchanged.

  NOTE: Must be public because it's called by code generated by defmapping macro."
  ([m k v]
   (if (nil? v) m (assoc m k v)))
  ([m k v translation]
   (if (nil? v) m (assoc m k (translate :from-ib translation v)))))

(defn assoc-nested
  "Assoc a nested object by converting it to a map.

  NOTE: Must be public because it's called by code generated by defmapping macro."
  [m k v]
  (if (nil? v) m (assoc m k (->map v))))

(defn emit-map<-field
  "Generates code for mapping a Java field to a map key.
  Used by defmapping macro.

  Options:
    :translation - Apply a translation from translation.clj
    :nested - Convert nested object using ->map"
  [this [k field & options]]
  (let [{:keys [translation nested]} (apply hash-map options)]
    (cond
      (not (nil? translation))
      `((assoc-if-val-non-nil ~k (. ~this ~field) ~translation))

      (not (nil? nested))
      `((assoc-nested ~k (. ~this ~field)))

      :else
      `((assoc-if-val-non-nil ~k (. ~this ~field))))))

(defn emit-map->field
  "Generates code for mapping a map key to a Java field.
  Used by defmapping macro.

  Options:
    :translation - Apply a translation from translation.clj
    :nested - Convert nested map using map->"
  [m this [key field & options]]
  (let [{:keys [translation nested]} (apply hash-map options)
        val (gensym "val")]
    `((if (contains? ~m ~key)
        (let [~val (~key ~m)]
          (try
            (. ~this ~field
               ~(cond
                  (not (nil? translation)) `(translate :to-ib ~translation ~val)
                  (not (nil? nested)) `(map-> ~nested ~val)
                  :else `~val))
            (catch ClassCastException ex#
              (throw (ex-info (str "Failed to map field " ~(str field)
                                   ~(when translation
                                      (str ", using translation " translation))
                                   ", value \"" ~val "\"")
                              {:class (class ~this)
                               :key ~key
                               :field ~(str field)
                               :translation ~translation}
                              ex#)))))))))

;; ============================================================================
;; Public macros - Used by generated_mappings.clj
;; ============================================================================

(defmacro defmapping
  "Define bidirectional mapping between a Java class and Clojure maps.

  Creates:
    1. ->map implementation (Java object → Clojure map)
    2. map-> method (Clojure map → Java object)

  Usage:
    (defmapping com.ib.client.Order
      [:action action :translation :order-action]
      [:quantity totalQuantity :translation :string-to-decimal]
      [:limit-price lmtPrice])

  Field syntax:
    [:kebab-key javaGetter]
    [:kebab-key javaGetter :translation :translation-key]
    [:kebab-key javaGetter :nested com.ib.client.NestedClass]"
  [c & field-keys]
  (let [this (gensym "this")
        field-map (gensym "field-map")]
    `(do
       ;; Extend the Java class with ->map
       (extend-type ~c
         Mappable
         (->map [~this]
           (-> {} ~@(mapcat (partial emit-map<-field this) field-keys))))

       ;; Add map-> method for converting maps to Java objects
       (defmethod map-> ~c [_# ~field-map]
         (let [~this (new ~c)]
           ~@(mapcat (partial emit-map->field field-map this) field-keys)
           ~this)))))

(defmacro defmapping-readonly
  "Define read-only mapping from Java class to Clojure maps.

  Like defmapping but only creates ->map, not map->.
  Used for classes without public constructors.

  Usage:
    (defmapping-readonly com.ib.client.Bar
      [:time time]
      [:open open]
      [:close close])"
  [c & field-keys]
  (let [this (gensym "this")]
    `(extend-type ~c
       Mappable
       (->map [~this]
         (-> {} ~@(mapcat (partial emit-map<-field this) field-keys))))))